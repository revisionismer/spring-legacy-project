<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:security="http://www.springframework.org/schema/security"
	xsi:schemaLocation="http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-5.6.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<!-- 1-4. BycrptPasswordEncoder 빈으로 등록 -->
	<bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder" />
	
	<!-- 2-1. custom403ExceptionHandler 빈으로 등록 -->
	<bean id="custom403ExceptionHandler" class="com.nexchal.config.security.handler.Custom403ExceptionHandler" />
	
	<!-- 2-5. customLoginSuccessHandler 빈으로 등록 -->
	<bean id="customLoginSuccessHandler" class="com.nexchal.config.security.handler.CustomLoginSuccessHandler"/>
		
	<!-- 2-7. CustomLogoutSuccessHandler 빈으로 등록 -->
	<bean id="customLogoutSuccessHandler" class="com.nexchal.config.security.handler.CustomLogoutSuccessHandler"/>
		
	<!-- 1-1. security:http 설정이 안되어 있을때 no bean 관련 에러가 터지니 시큐리티 의존성 추가후 반드시 작성 -->
	<security:http>
		<!-- 1-1. -->
		<!-- 2-3. 내가 사용할 기본 로그인 접근 경로는 /user/login이라고 선언-->
		<!-- 2-6. CustomLoginSuccessHandler를 폼로그인 ref로 등록 : 인증에 성공했을 떄 커스텀으로 처리하기 위해 등록 -->
		<security:form-login 
			login-page="/user/login" 
			authentication-success-handler-ref="customLoginSuccessHandler"
		/>
		
		<!-- 2.4. CSRF(Cross-Site Request Forgery) 토큰 비활성화 : 로그인 페이지 만들기 전 설정 -->
		<security:csrf disabled="true" />
		
		<!-- 1-3. 스프링 시큐리티 인증 설정 1 : Filter 단계(URL 보안) : xml에서 이 설정이 되어 있으면 어노테이션 기반 @PreAuthorize("isAuthenticated()")이 동작 하지 않는다. 
		                                                                      필터 단에서 이미 인증 로직이 끝나기 때문에 컨트롤러 단에서 검사를 하지 않는다. 
		                                                                      그래서 어노테이션 기반을 테스터 하고 싶으면  security:intercept-url 설정을 모두 주석 처리 하고 테스트 하자. -->
		<!-- ex) 실행순서
				 요청
 				 ↓
				Spring Security Filter (intercept-url)
 				 ↓  ← 여기서 이미 인증 체크 끝남
				Controller
 				 ↓
				Service (@PreAuthorize)
		 -->		
		<!-- Filter 기반 시큐리티 적용 : 어노테이션 기반, 필터 기반 같이 쓸 수 있음. 컨트롤러에 @PreAuthorize를 걸지 말고 서비스단에 걸어서 사용하면 된다. -->                                                             
		<security:intercept-url pattern="/sample/all" access="permitAll()" />
		<security:intercept-url pattern="/sample/user" access="hasAnyRole('ROLE_USER', 'ROLE_ADMIN')" />
		<security:intercept-url pattern="/sample/admin" access="hasRole('ROLE_ADMIN')" />
	
		<security:intercept-url pattern="/board/register" method="GET" access="isAuthenticated()" />
		<security:intercept-url pattern="/board/register" method="POST" access="isAuthenticated()" />
 		    
	
		<!-- 2-2. 2-1에 등록한 custom403ExceptionHandler 빈을 연결  -->
		<security:access-denied-handler ref="custom403ExceptionHandler" />
	
		<!-- 2-8. 2-7에서 등록해놓은 CustomLogoutHadnler 빈을 연결 -->
		<security:logout success-handler-ref="customLogoutSuccessHandler" />
	
		<!-- 2-10. remember-me 설정 2 : 초단위, 604800초 -> 7일(1주일), remember-me 설정 1은 login.jsp의 remember-me 체크박스에 되어 있다. -->
		<!-- 2-11. DB와 연동 하기 위해 data-source-ref 설정을 해준다 우리는 root-context.xml에 설정한 dataSource를 사용(name으로 dataSource 이름이 bean으로 등록되어 있어야한다.), 관련 테이블 생성 정보는 : https://docs.spring.io/spring-security/reference/servlet/authentication/rememberme.html -->
		<!-- 2-12. remember-me에 dataSource를 연결해서 저장하는 로직을 실행할때 UserDetailsService를 사용하는데 우리는 CustomUserDetailsService라는 이름으로 사용했기 떄문에 user-service-ref 속성에 이름을 셋팅해준다.  -->
		<!-- 2-14.  persistentTokenRepository bean을 token-repository-ref 설정 -->
		<!-- 
			CREATE TABLE persistent_logins (
   				username VARCHAR(64) NOT NULL,
    			series VARCHAR(64) PRIMARY KEY,
    			token VARCHAR(64) NOT NULL,
    			last_used TIMESTAMP NOT NULL
			);
		 -->
		<security:remember-me token-validity-seconds="604800" token-repository-ref="persistentTokenRepository" user-service-ref="customUserDetailsService" />
	</security:http>
	
	<!-- 2-13. JdbcTokenRepositoryImpl 기반 persistentTokenRepository 설정 -->
	<bean id="persistentTokenRepository" class="org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl">
    	<property name="dataSource" ref="dataSource"/>
	</bean>
	
	<!-- 1-6. CustomUserDetailsService class를 bean으로 등록 -->
	<bean id="customUserDetailsService" name="customUserDetailsService" class="com.nexchal.config.security.service.CustomUserDetailsService">
		<!-- 1-8. 기본 생성자 xml에서 생성, mapper 어노테이션으로 이미 userMapper란 이름으로 bean으로 등록 되어 있기 떄문에 가능, 
		                      경고가 뜨는 이유는 해당 xml파일 안에 userMapper란 id로 등록된 bean이 없어서 그런데 무시하자(버전문제인듯) -->
		<constructor-arg index="0" ref="userMapper"></constructor-arg>
	</bean>
	
	<!-- 1-2. -->
	<security:authentication-manager>
		<!-- 1-5. -->
		<!-- 1-7. user-service-ref 속성에 내가 만들어서 bean으로 등록한 UserDetailsService 클래스를 등록 -->
		<security:authentication-provider user-service-ref="customUserDetailsService">
			
			<!-- 2-14. -->
			<security:password-encoder ref="passwordEncoder"/>
		</security:authentication-provider>
		
	</security:authentication-manager>
	
	<!-- 3-1. 시큐리티 어노테이션 활성화 설정 코드 -->	
	<security:global-method-security secured-annotations="enabled" pre-post-annotations="enabled" /> 
</beans>